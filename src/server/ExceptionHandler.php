<?php
// BlogSTEP 
// Copyright (c) 2016 Niels Sonnich Poulsen (http://nielssp.dk)
// Licensed under the MIT license.
// See the LICENSE file or http://opensource.org/licenses/MIT for more information.
namespace Blogstep;

use Jivoo\Http\Message\Response;
use Jivoo\Http\Message\Status;
use Jivoo\Log\ErrorException;
use Jivoo\Log\ErrorHandler;
use Jivoo\Log\Logger;
use Jivoo\Utilities;

/**
 * Handles uncaught exceptions and fatal errors.
 */
class ExceptionHandler
{

    /**
     * @var Modules
     */
    private $m;

    /**
     * @var string[]
     */
    private $errorPaths = [];

    public function __construct(Modules $m)
    {
        $this->m = $m;
        $this->m->required('logger');
        $this->m->required('paths');
        $this->m->required('main');
        $this->m->required('server');

        // Precompute paths used for error handling
        $logDir = $this->m->paths->p('var/log');
        if (Utilities::dirExists($logDir)) {
            $this->errorPaths['log'] = realpath($logDir);
        }
        $errorTemplate = $this->m->paths->p('src/templates/error/error.php');
        if (!file_exists($errorTemplate)) {
            throw new RuntimeException('Error template not found: ' . $errorTemplate);
        }
        $this->errorPaths['errorTemplate'] = realpath($errorTemplate);
        $exceptionTemplate = $this->m->paths->p('src/templates/error/exception.php');
        if (!file_exists($exceptionTemplate)) {
            throw new RuntimeException('Exception template not found: ' . $errorTemplate);
        }
        $this->errorPaths['exceptionTemplate'] = realpath($exceptionTemplate);
    }

    /**
     * Output an HTML crash report based on an exception.
     *
     * @param \Exception $exception Exception to create report for.
     * @return string HTML document.
     */
    public function crashReport($exception)
    {
        if ($exception instanceof \ErrorException) {
            $title = 'Fatal error (' . ErrorHandler::toString($exception->getSeverity()) . ')';
        } else {
            $title = 'Uncaught exception';
        }
        $log = [];
        if ($this->m->logger instanceof Logger) {
            $log = $this->m->logger->getLog();
        }
        ob_start();
        include $this->errorPaths['exceptionTemplate'];
        return ob_get_clean();
    }

    /**
     * Handler for uncaught exceptions.
     * @param \Exception $exception The exception.
     * @param bool Whether the exception was generated by a fatal PHP error.
     */
    public function handleError($exception, $fatal = false)
    {
        $this->m->logger->critical(
            'Uncaught exception: ' . $exception->getMessage() . ' in ' . $exception->getFile() . ':' . $exception->getLine(),
            ['exception' => $exception]
        );
        if ($this->m->main->config['debug.createCrashReports']) {
            $file = $exception->getFile();
            $line = $exception->getLine();
            $message = $exception->getMessage();
            $hash = substr(md5($file . $line . $message), 0, 10);
            $name = date('Y-m-d') . '_crash_' . $hash . '.html';
            if (!isset($this->errorPaths['log'])) {
                $this->m->logger->alert('Could not create crash report: Log directory is missing');
            } elseif (!file_exists($this->errorPaths['log'] . '/' . $name)) {
                $file = fopen($this->errorPaths['log'] . '/' . $name, 'w');
                if ($file !== false) {
                    $this->crashReport($exception);
                    fwrite($file, $this->crashReport($exception));
                    fclose($file);
                    $this->m->logger->critical('A crash report has been generated: {name}', ['name' => $name]);
                } else {
                    $hash = null;
                    $this->m->logger->alert('Failed to create crash report: {name}', ['name' => $name]);
                }
            }
            if (!$this->m->main->config['debug.showReference']) {
                $hash = null;
            }
        }
        if (headers_sent()) {
            echo 'Uncaught exception: ' . $exception->getMessage();
            exit;
        }
        // Clean the view
        while (ob_get_level() > 0) {
            ob_end_clean();
        }
        if (php_sapi_name() === 'cli') {
            Shell::dumpException($exception);
            exit;
        }
        $response = new Response(Status::INTERNAL_SERVER_ERROR);
        $response = $response->withHeader('Content-Type', 'text/html');
        if ($this->m->main->config['debug.showExceptions']) {
            $body = $this->crashReport($exception);
            $response->getBody()->write($body);
        } else {
            ob_start();
            include $this->errorPaths['errorTemplate'];
            $response->getBody()->write(ob_get_clean());
        }
        try {
          $this->m->server->serve($response);
        } catch (\Exception $e) {
            echo $response->getBody();
            exit;
        }
    }

    /**
     * Handle a fatal PHP error in the same way as uncaught exceptions: By logging
     * the error and presenting an error page.
     */
    public function handleFatalError()
    {
        $error = error_get_last();
        if ($error) {
            switch ($error['type']) {
                case E_ERROR:
                case E_PARSE:
                case E_CORE_ERROR:
                case E_COMPILE_ERROR:
                case E_USER_ERROR:
                    $this->handleError(new ErrorException(
                        $error['message'],
                        0,
                        $error['type'],
                        $error['file'],
                        $error['line']
                    ), true);
            }
        }
    }
    
    public function register()
    {
        set_exception_handler(array($this, 'handleError'));
        register_shutdown_function(array($this, 'handleFatalError'));
    }
}
